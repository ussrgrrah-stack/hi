--  CLEAN MAIN SCRIPT - ALL FEATURES INTEGRATED - IMPROVED AUTOBLOCK WITH FACING CHECK
local _ = string.char(87,65,82,78,73,78,71,58,32,68,79,32,78,79,84,32,69,68,73,84,10,79,119,110,101,114,58,32,54,100,97,121,49,51)

-- ========== SERVICES ==========
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local CoreGui = game:GetService("CoreGui")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Workspace = game:GetService("Workspace")
local UserInputService = game:GetService("UserInputService")
local lp = Players.LocalPlayer or Players.PlayerAdded:Wait()

-- ========== GLOBAL VARIABLES ==========
connections = connections or {}
mainConns = mainConns or {}
unloaded = false

local Storage = CoreGui:FindFirstChild("Highlight_Storage") or Instance.new("Folder")
Storage.Name = "Highlight_Storage"
Storage.Parent = CoreGui

-- ========== LOAD RAYFIELD ==========
local function makeFallbackRayfield()
    local DummyParagraph = { Set=function() end }
    local DummyTab = {
        CreateToggle=function() end, CreateSlider=function() end, CreateButton=function() end,
        CreateParagraph=function() return DummyParagraph end, CreateDropdown=function() end,
        CreateInput=function() end, CreateColorPicker=function() end,
    }
    return { CreateWindow=function() return { CreateTab=function() return DummyTab end } end }
end

local oldGui = CoreGui:FindFirstChild("Rayfield")
if oldGui then pcall(function() oldGui:Destroy() end) end

local Rayfield
do
    local ok, lib = pcall(function()
        return loadstring(game:HttpGet("https://sirius.menu/rayfield"))()
    end)
    Rayfield = (ok and lib and lib.CreateWindow) and lib or makeFallbackRayfield()
    if Rayfield.Notify then Rayfield.Notify = function() end end
end

local Window = Rayfield:CreateWindow({
    Name = "HUB (D OF D) TY @maxiedsu/gonnered ILIKES_KIWI",
    LoadingTitle = "Loading...TY @maxiedsu/gonnered",
    LoadingSubtitle = "by cutotoite_10",
    ConfigurationSaving = {Enabled = false}
})

-- ========== ESP SYSTEM ==========
local espConfigs = {
    Survivor = {Enabled=true, Name=true, HP=true, Fill=true, Outline=true, FillColor=Color3.fromRGB(0,255,0),   OutlineColor=Color3.fromRGB(0,255,0),   FillTransparency=0.5, OutlineTransparency=0},
    Killer   = {Enabled=true, Name=true, HP=true, Fill=true, Outline=true, FillColor=Color3.fromRGB(255,0,0),   OutlineColor=Color3.fromRGB(255,0,0),   FillTransparency=0.5, OutlineTransparency=0},
    Ghost    = {Enabled=true, Name=true, HP=true, Fill=true, Outline=true, FillColor=Color3.fromRGB(0,255,255), OutlineColor=Color3.fromRGB(0,255,255), FillTransparency=0.5, OutlineTransparency=0},
}
local DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
local TextStrokeColor = Color3.fromRGB(0,0,0)

local function createLabel(name,parent,posY)
    local label = Instance.new("TextLabel")
    label.Name = name
    label.Parent = parent
    label.BackgroundTransparency = 1
    label.Size = UDim2.new(1,0,0.5,0)
    label.Position = UDim2.new(0,0,posY,0)
    label.TextSize = 14
    label.Font = Enum.Font.SourceSansBold
    label.TextStrokeColor3 = TextStrokeColor
    label.TextStrokeTransparency = 0
    label.TextColor3 = Color3.fromRGB(255,255,255)
    return label
end

local function setupHealthDisplay(plr, humanoid, healthLabel)
    local function update()
        if not plr.Character then return end
        local team = plr.Character.Parent and plr.Character.Parent.Name
        local cfg = team and espConfigs[team]
        if cfg and cfg.HP and cfg.Enabled then
            healthLabel.Visible = true
            healthLabel.Text = ("HP: %d/%d"):format(math.floor(humanoid.Health), humanoid.MaxHealth)
        else
            healthLabel.Visible = false
        end
    end
    update()
    connections[plr] = connections[plr] or {}
    if connections[plr].HealthChanged then
        pcall(function() connections[plr].HealthChanged:Disconnect() end)
    end
    connections[plr].HealthChanged = humanoid.HealthChanged:Connect(update)
end

local function updateESPConfig(plr)
    if not plr or not plr.Character then return end
    local char = plr.Character
    local highlight = Storage:FindFirstChild(plr.Name.."_Highlight")
    local nametag = Storage:FindFirstChild(plr.Name.."_Nametag")
    local humanoid = char:FindFirstChildOfClass("Humanoid")
    local team = char.Parent and char.Parent.Name
    local cfg = espConfigs[team]
    if not cfg or not humanoid then return end

    if highlight then
        highlight.Enabled = cfg.Enabled
        highlight.FillColor = cfg.FillColor
        highlight.OutlineColor = cfg.OutlineColor
        highlight.FillTransparency = (cfg.Fill and cfg.FillTransparency) or 1
        highlight.OutlineTransparency = (cfg.Outline and cfg.OutlineTransparency) or 1
    end
    if nametag then
        local nameLabel = nametag:FindFirstChild("PlayerName")
        local healthLabel = nametag:FindFirstChild("HealthLabel")
        if nameLabel then 
            nameLabel.Visible = cfg.Enabled and cfg.Name
            nameLabel.TextColor3 = cfg.FillColor
            nameLabel.Text = plr.Name
        end
        if healthLabel then 
            healthLabel.Visible = cfg.Enabled and cfg.HP
        end
    end
end

local function cleanupESP(plr)
    for _, suffix in ipairs({"_Highlight","_Nametag"}) do
        local obj = Storage:FindFirstChild(plr.Name..suffix)
        if obj then pcall(function() obj:Destroy() end) end
    end
    if connections[plr] and connections[plr].HealthChanged then
        pcall(function() connections[plr].HealthChanged:Disconnect() end)
        connections[plr].HealthChanged = nil
    end
end

local function createOrUpdateESP(plr, char)
    if not char or not char.Parent or plr == lp or unloaded then return end
    local humanoid = char:FindFirstChildOfClass("Humanoid")
    local hrp = char:FindFirstChild("HumanoidRootPart")
    local team = char.Parent and char.Parent.Name
    local cfg = espConfigs[team]
    if not cfg or not humanoid then return end

    cleanupESP(plr)

    local highlight = Instance.new("Highlight")
    highlight.Name = plr.Name.."_Highlight"
    highlight.DepthMode = DepthMode
    highlight.Adornee = char
    highlight.Parent = Storage

    if not hrp then return end

    local nametag = Instance.new("BillboardGui")
    nametag.Name = plr.Name.."_Nametag"
    nametag.Size = UDim2.new(0,120,0,40)
    nametag.StudsOffset = Vector3.new(0,2.5,0)
    nametag.AlwaysOnTop = true
    nametag.Adornee = hrp
    nametag.Parent = Storage
    local nameLabel = createLabel("PlayerName", nametag, 0)
    nameLabel.Text = plr.Name
    local healthLabel = createLabel("HealthLabel", nametag, 0.5)

    updateESPConfig(plr)
    setupHealthDisplay(plr, humanoid, healthLabel)

    connections[plr].Died = humanoid.Died:Connect(function()
        cleanupESP(plr)
    end)

    connections[plr].CharacterRemoving = plr.CharacterRemoving:Connect(function()
        cleanupESP(plr)
    end)
end

local function onPlayerAdded(plr)
    if plr == lp then return end
    connections[plr] = connections[plr] or {}
    connections[plr].CharacterAdded = plr.CharacterAdded:Connect(function(char)
        task.wait(2.5)
        createOrUpdateESP(plr, char)
    end)
    if plr.Character then createOrUpdateESP(plr, plr.Character) end
end

local function onPlayerRemoving(plr)
    cleanupESP(plr)
    if connections[plr] then
        for _, conn in pairs(connections[plr]) do
            if typeof(conn) == "RBXScriptConnection" then
                pcall(function() conn:Disconnect() end)
            end
        end
        connections[plr] = nil
    end
end

mainConns.playersAdded = Players.PlayerAdded:Connect(onPlayerAdded)
mainConns.playersRemoving = Players.PlayerRemoving:Connect(onPlayerRemoving)
for _,v in ipairs(Players:GetPlayers()) do onPlayerAdded(v) end

local function updateAllESP()
    for _, plr in ipairs(Players:GetPlayers()) do
        if plr ~= lp then updateESPConfig(plr) end
    end
end

-- ESP UI
for teamName, cfg in pairs(espConfigs) do
    local tab = Window:CreateTab(teamName.." ESP", 4483362458)
    tab:CreateToggle({Name="Enable ESP", CurrentValue=cfg.Enabled, Callback=function(v) cfg.Enabled = v updateAllESP() end})
    tab:CreateToggle({Name="Show Name", CurrentValue=cfg.Name, Callback=function(v) cfg.Name = v updateAllESP() end})
    tab:CreateToggle({Name="Show HP", CurrentValue=cfg.HP, Callback=function(v) cfg.HP = v updateAllESP() end})
    tab:CreateToggle({Name="Show Fill", CurrentValue=cfg.Fill, Callback=function(v) cfg.Fill = v updateAllESP() end})
    tab:CreateColorPicker({Name="Fill Color", Color=cfg.FillColor, Callback=function(c) cfg.FillColor = c updateAllESP() end})
    tab:CreateSlider({Name="Fill Transparency", Range={0,1}, Increment=0.05, CurrentValue=cfg.FillTransparency, Callback=function(v) cfg.FillTransparency = v updateAllESP() end})
    tab:CreateToggle({Name="Show Outline", CurrentValue=cfg.Outline, Callback=function(v) cfg.Outline = v updateAllESP() end})
    tab:CreateColorPicker({Name="Outline Color", Color=cfg.OutlineColor, Callback=function(c) cfg.OutlineColor = c updateAllESP() end})
    tab:CreateSlider({Name="Outline Transparency", Range={0,1}, Increment=0.05, CurrentValue=cfg.OutlineTransparency, Callback=function(v) cfg.OutlineTransparency = v updateAllESP() end})
end

-- ESP Auto-Fix (Mobile)
local isMobile = UserInputService.TouchEnabled and not UserInputService.KeyboardEnabled
local lastEspCheck = 0
local ESP_CHECK_INTERVAL = 3

task.spawn(function()
    while not unloaded do
        local now = tick()
        if now - lastEspCheck < ESP_CHECK_INTERVAL then
            task.wait(0.1)
            continue
        end
        lastEspCheck = now
        
        if not isMobile then task.wait(ESP_CHECK_INTERVAL); continue end
        
        for _, plr in ipairs(Players:GetPlayers()) do
            if plr == lp or not plr.Character then continue end
            local char = plr.Character
            local team = char.Parent and char.Parent.Name
            local cfg = espConfigs[team]
            if not cfg or not cfg.Enabled then continue end
            
            local highlight = Storage:FindFirstChild(plr.Name.."_Highlight")
            if highlight and not highlight.Enabled then
                updateESPConfig(plr)
            end
            
            local nametag = Storage:FindFirstChild(plr.Name.."_Nametag")
            if nametag then
                local nameLabel = nametag:FindFirstChild("PlayerName")
                local healthLabel = nametag:FindFirstChild("HealthLabel")
                if (cfg.Name and nameLabel and not nameLabel.Visible) or (cfg.HP and healthLabel and not healthLabel.Visible) then
                    updateESPConfig(plr)
                end
            end
            
            if not highlight and not nametag then
                createOrUpdateESP(plr, char)
            end
        end
        
        task.wait(ESP_CHECK_INTERVAL)
    end
end)

-- ========== SPEED SETTINGS ==========
local character = lp.Character or lp.CharacterAdded:Wait()
if character:GetAttribute("WalkSpeed") == nil then character:SetAttribute("WalkSpeed", 10) end
if character:GetAttribute("SprintSpeed") == nil then character:SetAttribute("SprintSpeed", 27) end

local walkSpeedValue = character:GetAttribute("WalkSpeed") or 10
local sprintSpeedValue = character:GetAttribute("SprintSpeed") or 27
local walkSpeedEnabled = false
local sprintEnabled = false
local speedConnection = nil

local function updateSpeeds()
    if unloaded or not character then return end
    local currentWS = character:GetAttribute("WalkSpeed") or 10
    local currentSS = character:GetAttribute("SprintSpeed") or 27
    
    if walkSpeedEnabled and currentWS ~= walkSpeedValue then
        character:SetAttribute("WalkSpeed", walkSpeedValue)
    end
    if sprintEnabled and currentSS ~= sprintSpeedValue then
        character:SetAttribute("SprintSpeed", sprintSpeedValue)
    end
end

local function startSpeedLoop()
    if speedConnection then speedConnection:Disconnect() end
    speedConnection = RunService.Heartbeat:Connect(updateSpeeds)
end

local function stopSpeedLoop()
    if speedConnection then
        speedConnection:Disconnect()
        speedConnection = nil
    end
end

local tabSpeed = Window:CreateTab("Speed Settings", 4483362458)
tabSpeed:CreateSlider({Name="WalkSpeed", Range={8,200}, Increment=1, CurrentValue=walkSpeedValue, Callback=function(val) walkSpeedValue = val if walkSpeedEnabled then updateSpeeds() end end})
tabSpeed:CreateToggle({Name="Enable WalkSpeed", CurrentValue=walkSpeedEnabled, Callback=function(v) walkSpeedEnabled = v if v then startSpeedLoop() updateSpeeds() else if character then character:SetAttribute("WalkSpeed", 10) end stopSpeedLoop() end end})
tabSpeed:CreateSlider({Name="SprintSpeed", Range={16,300}, Increment=1, CurrentValue=sprintSpeedValue, Callback=function(val) sprintSpeedValue = val if sprintEnabled then updateSpeeds() end end})
tabSpeed:CreateToggle({Name="Enable Sprint", CurrentValue=sprintEnabled, Callback=function(v) sprintEnabled = v if v then startSpeedLoop() updateSpeeds() else if character then character:SetAttribute("SprintSpeed", 27) end stopSpeedLoop() end end})

mainConns.charAdded_speed = lp.CharacterAdded:Connect(function(char)
    character = char
    task.wait(0.5)
    if character:GetAttribute("WalkSpeed") == nil then character:SetAttribute("WalkSpeed", walkSpeedValue) end
    if character:GetAttribute("SprintSpeed") == nil then character:SetAttribute("SprintSpeed", sprintSpeedValue) end
    if walkSpeedEnabled or sprintEnabled then startSpeedLoop() end
end)

-- ========== INSTANT 0MS AUTO BLOCK SYSTEM (15 STUDS, FACING CHECK INTEGRATED) ==========
local AutoBlockConfig = {
    EnableAutoBlock = true,
    EnableCooldownDisplay = true,
    EnableDebugMode = false,
    DynamicCooldowns = true,
    ThreatMultiplier = 0.7,
}

local AutoBlockState = {
    WatcherEnabled = true,
    LastBlockTime = 0,
    BlockCooldown = 1,
    IsOnCooldown = false,
    ActiveKillers = {},
    ThreatLevels = {},
}

-- Facing Check Variables
local facingCheckEnabled = false       -- Toggle for enabling/disabling facing check
local customFacingDot = -0.3           -- Dot product threshold for facing angle (-1 to 1)
local facingVisualOn = false           -- Toggle for enabling/disabling facing check visual
local DETECTION_RANGE = 15            -- Detection range for killers (studs)
local detectionRangeSq = DETECTION_RANGE * DETECTION_RANGE -- Cached squared range
local facingVisuals = {}              -- [killer] = visual

local UseAbility = ReplicatedStorage:WaitForChild("Events"):WaitForChild("RemoteFunctions"):WaitForChild("UseAbility")

-- Facing Check Function
local function isFacing(localRoot, targetRoot)
    if not facingCheckEnabled then return true end

    -- Calculate direction from target to local player
    local dx = localRoot.Position.X - targetRoot.Position.X
    local dy = localRoot.Position.Y - targetRoot.Position.Y
    local dz = localRoot.Position.Z - targetRoot.Position.Z

    -- Compute magnitude (distance) and normalize to unit vector
    local mag = math.sqrt(dx*dx + dy*dy + dz*dz)
    if mag == 0 then return true end -- Edge case: same position
    local invMag = 1 / mag

    -- Unit direction vector components
    local ux, uy, uz = dx * invMag, dy * invMag, dz * invMag

    -- Cache target's look vector (direction they are facing)
    local lv = targetRoot.CFrame.LookVector
    local lx, ly, lz = lv.X, lv.Y, lv.Z

    -- Dot product to determine angle
    local dot = lx * ux + ly * uy + lz * uz
    return dot > customFacingDot
end

-- Update Visual for a Killer
local function updateFacingVisual(killer, visual)
    if not (killer and visual and visual.Parent) then return end
    local hrp = killer:FindFirstChild("HumanoidRootPart")
    if not hrp then return end

    -- Calculate angle from DOT threshold
    local dot = math.clamp(customFacingDot or -0.3, -1, 1)
    local angle = math.acos(dot)              -- Radians (0 to pi)
    local frac = angle / math.pi              -- Normalize to 0..1 (0 = narrow, 1 = wide)

    -- Scale radius based on detection range and angle
    local minFrac = 0.20                      -- Minimum disc size (20% of detectionRange)
    local radius = math.max(1, DETECTION_RANGE * (minFrac + (1 - minFrac) * frac))
    visual.Radius = radius
    visual.Height = 0.12

    -- Position the disc in front of the killer
    local forwardDist = DETECTION_RANGE * (0.35 + 0.15 * frac) -- Adjust forward distance
    local yOffset = -(hrp.Size.Y / 2 + 0.05) -- Slightly below HRP
    visual.CFrame = CFrame.new(0, yOffset, -forwardDist) * CFrame.Angles(math.rad(90), 0, 0)

    -- Check if local player is in range and facing
    local myRoot = lp.Character and lp.Character:FindFirstChild("HumanoidRootPart")
    local inRange = false
    local facingOkay = false

    if myRoot and hrp then
        local dist = (hrp.Position - myRoot.Position).Magnitude
        inRange = dist <= DETECTION_RANGE
        facingOkay = (not facingCheckEnabled) or isFacing(myRoot, hrp)
    end

    -- Update visual appearance
    if inRange and facingOkay then
        visual.Color3 = Color3.fromRGB(0, 255, 0) -- Green when in range and facing
        visual.Transparency = 0.40
    else
        visual.Color3 = Color3.fromRGB(255, 255, 0) -- Yellow otherwise
        visual.Transparency = 0.85
    end
end

-- Add Visual for a Killer
local function addFacingVisual(killer)
    if not killer or not killer:IsA("Model") then return end
    if facingVisuals[killer] then return end
    local hrp = killer:FindFirstChild("HumanoidRootPart")
    if not hrp then return end

    local visual = Instance.new("CylinderHandleAdornment")
    visual.Name = "FacingCheckVisual"
    visual.Adornee = hrp
    visual.AlwaysOnTop = true
    visual.ZIndex = 2
    visual.Transparency = 0.55
    visual.Color3 = Color3.fromRGB(0, 255, 0) -- Default green
    visual.Parent = hrp
    facingVisuals[killer] = visual

    -- Initialize visual placement
    updateFacingVisual(killer, visual)
end

-- Remove Visual for a Killer
local function removeFacingVisual(killer)
    local v = facingVisuals[killer]
    if v then
        v:Destroy()
        facingVisuals[killer] = nil
    end
end

-- Refresh All Visuals
local function refreshFacingVisuals()
    local killersFolder = Workspace:FindFirstChild("GameAssets") and Workspace.GameAssets:FindFirstChild("Teams") and Workspace.GameAssets.Teams:FindFirstChild("Killer")
    if not killersFolder then return end
    for _, k in ipairs(killersFolder:GetChildren()) do
        if facingVisualOn then
            local hrp = k:FindFirstChild("HumanoidRootPart") or k:WaitForChild("HumanoidRootPart", 5)
            if hrp then addFacingVisual(k) end
        else
            removeFacingVisual(k)
        end
    end
end

-- Update Visuals Every Frame
RunService.RenderStepped:Connect(function()
    for killer, visual in pairs(facingVisuals) do
        if not killer.Parent or not killer:FindFirstChild("HumanoidRootPart") then
            removeFacingVisual(killer)
        else
            updateFacingVisual(killer, visual)
        end
    end
end)

-- Killer Configurations (15 studs base, facing check optional)
local KillerConfigs = {
    ["Pursuer"] = {
        enabled = true,
        priority = 1,
        baseDistance = 15,
        speedMultiplier = 0.12,
        validSpeeds = {4, 6, 7, 8, 10, 12, 14, 16, 18, 20, 22, 24},
        threatWeight = 1.2,
        check = function(self, killerFolder, ws)
            if ws <= 3 then return false end
            for _, v in ipairs(self.validSpeeds) do
                if math.abs(ws - v) < 0.8 then return true end
            end
            return false
        end,
        calculateDistance = function(self, ws)
            return self.baseDistance + (ws * self.speedMultiplier)
        end
    },
    
    ["Artful"] = {
        enabled = true,
        priority = 2,
        baseDistance = 15,
        speedMultiplier = 0.12,
        validSpeeds = {4, 7, 8, 9, 12, 13, 16, 17, 18, 20, 21, 23},
        threatWeight = 0.9,
        check = function(self, killerFolder, ws)
            if ws <= 3 then return false end
            for _, v in ipairs(self.validSpeeds) do
                if math.abs(ws - v) < 0.8 then return true end
            end
            return false
        end,
        calculateDistance = function(self, ws)
            return self.baseDistance + (ws * self.speedMultiplier)
        end
    },
    
    ["Harken"] = {
        enabled = true,
        priority = 3,
        baseDistance = 15,
        speedMultiplier = 0.20,
        normalSpeeds = {4, 8, 12, 16, 18, 20, 22},
        enragedSpeeds = {5, 7.5, 10, 13.5, 17.5, 20, 21.5, 23, 25.5},
        threatWeight = 1.1,
        check = function(self, killerFolder, ws)
            if killerFolder:GetAttribute("AgitationCooldown") then return true end
            if ws <= 3 then return false end
            local enraged = killerFolder:GetAttribute("Enraged")
            local speeds = enraged and self.enragedSpeeds or self.normalSpeeds
            for _, v in ipairs(speeds) do
                if math.abs(ws - v) < 0.8 then return true end
            end
            return false
        end,
        calculateDistance = function(self, ws)
            local multiplier = self.speedMultiplier
            if ws > 20 then multiplier = multiplier * 1.2 end
            return self.baseDistance + (ws * multiplier)
        end
    },
    
    ["Badware"] = {
        enabled = true,
        priority = 4,
        baseDistance = 15,
        speedMultiplier = 0.08,
        validSpeeds = {4, 8, 12, 16, 18, 20, 22},
        threatWeight = 1.0,
        state = { active = false, startTime = 0, lastWS = nil, isTeleporting = false },
        check = function(self, killerFolder, ws)
            local now = tick()
            local isValidSpeed = false
            
            for _, v in ipairs(self.validSpeeds) do
                if math.abs(ws - v) < 0.8 then
                    isValidSpeed = true
                    break
                end
            end
            
            if isValidSpeed then
                if not self.state.active then
                    self.state.startTime = now
                    self.state.active = true
                    self.state.lastWS = ws
                    self.state.isTeleporting = false
                else
                    self.state.lastWS = ws
                end
                return true
            else
                if self.state.active then
                    local duration = now - self.state.startTime
                    self.state.active = false
                    
                    if duration < 0.10 then
                        self.state.isTeleporting = true
                        task.delay(0.20, function()
                            self.state.isTeleporting = false
                        end)
                        return true
                    end
                end
            end
            
            return false
        end,
        calculateDistance = function(self, ws)
            return self.baseDistance + (ws * self.speedMultiplier)
        end
    },
    
    ["Killdroid"] = {
        enabled = true,
        priority = 5,
        baseDistance = 15,
        speedMultiplier = 0.08,
        validSpeeds = {-4, 0, 4, 12, 16, 18, 20, 22},
        threatWeight = 0.8,
        check = function(self, killerFolder, ws)
            for _, v in ipairs(self.validSpeeds) do
                if math.abs(ws - v) < 0.8 then return true end
            end
            return false
        end,
        calculateDistance = function(self, ws)
            return self.baseDistance + (math.abs(ws) * self.speedMultiplier)
        end
    }
}

local function sendBlock()
    local now = tick()
    local effectiveCD = AutoBlockState.BlockCooldown
    if AutoBlockConfig.DynamicCooldowns then
        local avgThreat = 0
        local count = 0
        for _, threat in pairs(AutoBlockState.ThreatLevels) do
            avgThreat = avgThreat + threat
            count = count + 1
        end
        if count > 0 then
            local globalThreat = avgThreat / count
            effectiveCD = effectiveCD * math.max(0.7, 1 - (globalThreat * AutoBlockConfig.ThreatMultiplier))
        end
    end
    -- Instant trigger - 0ms reaction
    if now - AutoBlockState.LastBlockTime < effectiveCD then
        return false
    end
    
    AutoBlockState.LastBlockTime = now
    AutoBlockState.IsOnCooldown = true
    
    local success = pcall(function()
        UseAbility:InvokeServer("Block")
    end)
    
    if AutoBlockConfig.EnableDebugMode then
        print("[AutoBlock] Block fired INSTANTLY (0ms) | CD: " .. string.format("%.2f", effectiveCD) .. "s | Success:", success)
    end
    
    return success
end

local function getDistance(killer)
    local killerHRP = killer:FindFirstChild("HumanoidRootPart")
    local playerHRP = lp.Character and lp.Character:FindFirstChild("HumanoidRootPart")
    if not (killerHRP and playerHRP) then return math.huge end
    return (killerHRP.Position - playerHRP.Position).Magnitude
end

local function checkAndBlock(killer)
    if not (AutoBlockState.WatcherEnabled and AutoBlockConfig.EnableAutoBlock and killer) or AutoBlockState.IsOnCooldown then
        return
    end
    
    local ws = killer:GetAttribute("WalkSpeedModifier") or 0
    local killerName = killer:GetAttribute("KillerName")
    if not killerName then return end
    
    local config = KillerConfigs[killerName]
    if not config or not config.enabled then return end
    
    local killerHRP = killer:FindFirstChild("HumanoidRootPart")
    local playerHRP = lp.Character and lp.Character:FindFirstChild("HumanoidRootPart")
    if not (killerHRP and playerHRP) then return end
    
    local distance = getDistance(killer)
    local baseReq = config.calculateDistance(config, ws)
    local requiredDistance = baseReq
    
    -- Fallback: If close + moving, bypass exact WS check
    local useFallback = (distance < (config.baseDistance * 1.5)) and ws > 3 and not config.check(config, killer, ws)
    local isValidWS = config.check(config, killer, ws) or useFallback
    
    if not isValidWS then return end
    
    -- Check if killer is facing the player
    local facingOkay = isFacing(playerHRP, killerHRP)
    if not facingOkay then return end
    
    -- Enhanced Relative velocity boost for chases
    local relativeBoost = 1.0
    local relSpeed = 0
    if killerHRP:FindFirstChild("Velocity") and playerHRP:FindFirstChild("Velocity") then
        local killerVel = killerHRP.Velocity
        local playerVel = playerHRP.Velocity
        local dirToPlayer = (playerHRP.Position - killerHRP.Position).Unit
        relSpeed = killerVel:Dot(dirToPlayer) - playerVel:Dot(dirToPlayer)
        if relSpeed > 7 then
            relativeBoost = 1.25 + (relSpeed / 50)
            if AutoBlockConfig.EnableDebugMode then
                print(string.format("[AutoBlock] High Threat Chase! RelSpeed: %.1f | Boost: %.2fx", relSpeed, relativeBoost))
            end
        end
    end
    requiredDistance = baseReq * relativeBoost
    
    -- Update Threat Level
    local threat = math.clamp((relSpeed / 20 + (config.baseDistance / distance)) / 2, 0, 1) * config.threatWeight
    AutoBlockState.ThreatLevels[killer] = threat
    
    local logExtra = useFallback and " (Fallback!)" or ""
    if AutoBlockConfig.EnableDebugMode then
        print(string.format("[AutoBlock] %s | WS:%.2f%s | Dist:%.1f | Req:%.1f (Boost:%.2fx) | Threat:%.2f | Facing:%s", killerName, ws, logExtra, distance, requiredDistance, relativeBoost, threat, tostring(facingOkay)))
    end
    
    if distance <= requiredDistance then
        if sendBlock() and AutoBlockConfig.EnableDebugMode then
            print(string.format("[AutoBlock] ðŸ›¡ï¸ BLOCKED %s @ %.1f studs (Threat: %.2f)", killerName, distance, threat))
        end
    end
end

local function monitorKiller(killer)
    if not killer or AutoBlockState.ActiveKillers[killer] then return end
    AutoBlockState.ActiveKillers[killer] = true
    AutoBlockState.ThreatLevels[killer] = 0
    
    -- Instant initial check
    checkAndBlock(killer)
    
    if not killer:GetAttribute("__AutoBlock_Connected") then
        killer:SetAttribute("__AutoBlock_Connected", true)
        killer.AttributeChanged:Connect(function(attr)
            if attr:match("WalkSpeedModifier|KillerName|Enraged|AgitationCooldown") then
                task.spawn(function() checkAndBlock(killer) end)
            end
        end)
    end
    
    -- Every-frame check for instant 0ms reaction
    local heartbeatConn = RunService.Heartbeat:Connect(function()
        if not killer or not killer.Parent then
            heartbeatConn:Disconnect()
            AutoBlockState.ActiveKillers[killer] = nil
            AutoBlockState.ThreatLevels[killer] = nil
            removeFacingVisual(killer)
            return
        end
        checkAndBlock(killer)
    end)
end

local killersFolder = Workspace:WaitForChild("GameAssets"):WaitForChild("Teams"):WaitForChild("Killer")

for _, killer in pairs(killersFolder:GetChildren()) do
    task.spawn(monitorKiller, killer)
end

killersFolder.ChildAdded:Connect(function(killer)
    task.wait()
    monitorKiller(killer)
    if facingVisualOn then
        task.spawn(function()
            local hrp = killer:WaitForChild("HumanoidRootPart", 5)
            if hrp then addFacingVisual(killer) end
        end)
    end
end)

killersFolder.ChildRemoved:Connect(function(killer)
    removeFacingVisual(killer)
end)

local function updateWatcherState()
    local isKiller = killersFolder:FindFirstChild(lp.Name) ~= nil
    AutoBlockState.WatcherEnabled = not isKiller
end

-- Cooldown Display
local CooldownGUI = Instance.new("ScreenGui")
CooldownGUI.Name = "AutoBlockCooldown"
CooldownGUI.ResetOnSpawn = false
CooldownGUI.Parent = lp:WaitForChild("PlayerGui")

local CooldownFrame = Instance.new("Frame")
CooldownFrame.Size = UDim2.new(0, 150, 0, 100)
CooldownFrame.Position = UDim2.new(1, -160, 0, 10)
CooldownFrame.AnchorPoint = Vector2.new(1, 0)
CooldownFrame.BackgroundColor3 = Color3.fromRGB(20, 20, 20)
CooldownFrame.BorderSizePixel = 0
CooldownFrame.Parent = CooldownGUI

local Corner = Instance.new("UICorner")
Corner.CornerRadius = UDim.new(0, 8)
Corner.Parent = CooldownFrame

local Stroke = Instance.new("UIStroke")
Stroke.Color = Color3.fromRGB(0, 255, 0)
Stroke.Thickness = 2
Stroke.Parent = CooldownFrame

local Title = Instance.new("TextLabel")
Title.Size = UDim2.new(1, 0, 0, 25)
Title.BackgroundTransparency = 1
Title.Text = "AutoBlock ULTRA"
Title.TextColor3 = Color3.fromRGB(255, 255, 255)
Title.Font = Enum.Font.GothamBold
Title.TextSize = 14
Title.Parent = CooldownFrame

local StatusLabel = Instance.new("TextLabel")
StatusLabel.Size = UDim2.new(1, -10, 0, 20)
StatusLabel.Position = UDim2.new(0, 5, 0, 30)
StatusLabel.BackgroundTransparency = 1
StatusLabel.Text = "Ready"
StatusLabel.TextColor3 = Color3.fromRGB(0, 255, 0)
StatusLabel.Font = Enum.Font.GothamBold
StatusLabel.TextSize = 16
StatusLabel.TextXAlignment = Enum.TextXAlignment.Center
StatusLabel.Parent = CooldownFrame

local ThreatLabel = Instance.new("TextLabel")
ThreatLabel.Size = UDim2.new(1, -10, 0, 15)
ThreatLabel.Position = UDim2.new(0, 5, 0, 50)
ThreatLabel.BackgroundTransparency = 1
ThreatLabel.Text = "Threat: Low"
ThreatLabel.TextColor3 = Color3.fromRGB(255, 255, 0)
ThreatLabel.Font = Enum.Font.Gotham
ThreatLabel.TextSize = 12
ThreatLabel.TextXAlignment = Enum.TextXAlignment.Center
ThreatLabel.Parent = CooldownFrame

local BarBG = Instance.new("Frame")
BarBG.Size = UDim2.new(1, -20, 0, 15)
BarBG.Position = UDim2.new(0, 10, 0, 70)
BarBG.BackgroundColor3 = Color3.fromRGB(40, 40, 40)
BarBG.BorderSizePixel = 0
BarBG.Parent = CooldownFrame

local BarCorner = Instance.new("UICorner")
BarCorner.CornerRadius = UDim.new(0, 4)
BarCorner.Parent = BarBG

local BarFill = Instance.new("Frame")
BarFill.Size = UDim2.new(0, 0, 1, 0)
BarFill.BackgroundColor3 = Color3.fromRGB(255, 0, 0)
BarFill.BorderSizePixel = 0
BarFill.Parent = BarBG

local FillCorner = Instance.new("UICorner")
FillCorner.CornerRadius = UDim.new(0, 4)
FillCorner.Parent = BarFill

-- Draggable
local dragging, dragInput, startPos, frameStart = false, nil, nil, nil
local function updatePosition(delta)
    if frameStart then
        CooldownFrame.Position = UDim2.new(frameStart.X.Scale, frameStart.X.Offset + delta.X, frameStart.Y.Scale, frameStart.Y.Offset + delta.Y)
    end
end
local function inputBegan(input)
    if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
        dragging = true
        dragInput = input
        startPos = input.Position
        frameStart = CooldownFrame.Position
        input.Changed:Connect(function()
            if input.UserInputState == Enum.UserInputState.End then
                dragging = false
                dragInput = nil
            end
        end)
    end
end
local function inputChanged(input)
    if input == dragInput and dragging then
        local delta = input.Position - startPos
        updatePosition(delta)
    end
end
CooldownFrame.InputBegan:Connect(inputBegan)
CooldownFrame.InputChanged:Connect(inputChanged)
UserInputService.InputChanged:Connect(inputChanged)

local function updateCooldownDisplay()
    if not AutoBlockConfig.EnableCooldownDisplay then
        CooldownGUI.Enabled = false
        return
    end
    CooldownGUI.Enabled = true
    
    local survivorFolder = Workspace:FindFirstChild("GameAssets") and Workspace.GameAssets:FindFirstChild("Teams") and Workspace.GameAssets.Teams:FindFirstChild("Survivor") and Workspace.GameAssets.Teams.Survivor:FindFirstChild(lp.Name)
    
    if not survivorFolder then
        StatusLabel.Text = "Not Survivor"
        StatusLabel.TextColor3 = Color3.fromRGB(255, 255, 0)
        ThreatLabel.Text = "Threat: N/A"
        BarFill.Size = UDim2.new(0, 0, 1, 0)
        Stroke.Color = Color3.fromRGB(255, 255, 0)
        return
    end
    
    local onCD = survivorFolder:GetAttribute("BlockCooldown")
    if onCD then
        StatusLabel.Text = "On Cooldown"
        StatusLabel.TextColor3 = Color3.fromRGB(255, 0, 0)
        Stroke.Color = Color3.fromRGB(255, 0, 0)
        local progress = math.clamp((tick() - AutoBlockState.LastBlockTime) / AutoBlockState.BlockCooldown, 0, 1)
        BarFill.Size = UDim2.new(1 - progress, 0, 1, 0)
        BarFill.BackgroundColor3 = Color3.fromRGB(255, 0, 0)
        AutoBlockState.IsOnCooldown = true
    else
        StatusLabel.Text = "Ready"
        StatusLabel.TextColor3 = Color3.fromRGB(0, 255, 0)
        Stroke.Color = Color3.fromRGB(0, 255, 0)
        BarFill.Size = UDim2.new(0, 0, 1, 0)
        BarFill.BackgroundColor3 = Color3.fromRGB(0, 255, 0)
        AutoBlockState.IsOnCooldown = false
    end
    
    -- Update Threat Display
    local avgThreat = 0
    local count = 0
    for _, threat in pairs(AutoBlockState.ThreatLevels) do
        avgThreat = avgThreat + threat
        count = count + 1
    end
    local globalThreat = count > 0 and (avgThreat / count) or 0
    local threatText = globalThreat > 0.7 and "HIGH" or globalThreat > 0.4 and "MED" or "LOW"
    local threatColor = globalThreat > 0.7 and Color3.fromRGB(255, 0, 0) or globalThreat > 0.4 and Color3.fromRGB(255, 165, 0) or Color3.fromRGB(0, 255, 0)
    ThreatLabel.Text = "Threat: " .. threatText .. " (" .. string.format("%.1f", globalThreat * 100) .. "%)"
    ThreatLabel.TextColor3 = threatColor
end

RunService.Heartbeat:Connect(function()
    updateWatcherState()
    updateCooldownDisplay()
end)

-- AutoBlock Tab
local tabAutoBlock = Window:CreateTab("AutoBlock ULTRA", 4483362458)

tabAutoBlock:CreateToggle({
    Name = "Enable AutoBlock",
    CurrentValue = AutoBlockConfig.EnableAutoBlock,
    Callback = function(v)
        AutoBlockConfig.EnableAutoBlock = v
    end
})

tabAutoBlock:CreateToggle({
    Name = "Show Cooldown Display",
    CurrentValue = AutoBlockConfig.EnableCooldownDisplay,
    Callback = function(v)
        AutoBlockConfig.EnableCooldownDisplay = v
        CooldownGUI.Enabled = v
    end
})

local removeAnimEnabled = false
tabAutoBlock:CreateToggle({
    Name = "Delete Block Animation",
    CurrentValue = removeAnimEnabled,
    Callback = function(v) removeAnimEnabled = v end
})

tabAutoBlock:CreateToggle({
    Name = "Debug Mode",
    CurrentValue = AutoBlockConfig.EnableDebugMode,
    Callback = function(v) 
        AutoBlockConfig.EnableDebugMode = v 
        if v then
            print("[AutoBlock ULTRA] Debug ON - 0ms instant blocking at 15 studs!")
        end
    end
})

tabAutoBlock:CreateToggle({
    Name = "Enable Dynamic Cooldowns",
    CurrentValue = AutoBlockConfig.DynamicCooldowns,
    Callback = function(v) AutoBlockConfig.DynamicCooldowns = v end
})

tabAutoBlock:CreateToggle({
    Name = "Enable Facing Check",
    CurrentValue = facingCheckEnabled,
    Callback = function(v) facingCheckEnabled = v end
})

tabAutoBlock:CreateToggle({
    Name = "Facing Check Visual",
    CurrentValue = facingVisualOn,
    Callback = function(v)
        facingVisualOn = v
        refreshFacingVisuals()
    end
})

tabAutoBlock:CreateInput({
    Name = "Facing Check Angle (DOT)",
    PlaceholderText = "-0.3",
    RemoveTextAfterFocusLost = false,
    Callback = function(text)
        customFacingDot = tonumber(text) or customFacingDot
    end
})

tabAutoBlock:CreateSlider({
    Name = "Detection Range",
    Range = {5, 30},
    Increment = 1,
    Suffix = " studs",
    CurrentValue = DETECTION_RANGE,
    Callback = function(v)
        DETECTION_RANGE = v
        detectionRangeSq = DETECTION_RANGE * DETECTION_RANGE
        refreshFacingVisuals()
    end
})

tabAutoBlock:CreateParagraph({
    Title = "DOT Explanation",
    Content = "DOT controls the facing cone size. 0 = directly in front, -0.3/-0.5 = wider cone, -1 = half-circle in front of the killer."
})

for killerName, cfg in pairs(KillerConfigs) do
    tabAutoBlock:CreateToggle({
        Name = "Enable " .. killerName,
        CurrentValue = cfg.enabled,
        Callback = function(val) cfg.enabled = val end
    })
end

-- Animation remover loop
task.spawn(function()
    while not unloaded do
        task.wait(0.1)
        if removeAnimEnabled and lp.Character then
            local humanoid = lp.Character:FindFirstChildOfClass("Humanoid")
            if humanoid then
                for _, track in ipairs(humanoid:GetPlayingAnimationTracks()) do
                    if track.Animation and tostring(track.Animation.AnimationId):match("134233326423882") then
                        track:Stop()
                    end
                end
            end
        end
    end
end)

-- ========== SKILLS & SELECTOR ==========
local skillList = {"Revolver","Punch","Block","Caretaker","Hotdog","Taunt","Cloak","Dash","Banana","BonusPad","Adrenaline"}
local selectedSkill1, selectedSkill2 = "Revolver", "Caretaker"

local tabSkills = Window:CreateTab("Skills & Selector", 4483362458)
local skillParagraph = tabSkills:CreateParagraph({Title = "Selected Skills", Content = "Skill 1: "..selectedSkill1.."\nSkill 2: "..selectedSkill2})

tabSkills:CreateDropdown({Name = "Select Skill 1", Options = skillList, CurrentOption = {selectedSkill1}, Callback = function(opt) selectedSkill1 = opt[1] skillParagraph:Set({Content="Skill 1: "..selectedSkill1.."\nSkill 2: "..selectedSkill2}) end})
tabSkills:CreateDropdown({Name = "Select Skill 2", Options = skillList, CurrentOption = {selectedSkill2}, Callback = function(opt) selectedSkill2 = opt[1] skillParagraph:Set({Content="Skill 1: "..selectedSkill1.."\nSkill 2: "..selectedSkill2}) end})
tabSkills:CreateButton({Name = "Select Skills", Callback = function() ReplicatedStorage:WaitForChild("Events"):WaitForChild("RemoteEvents"):WaitForChild("AbilitySelection"):FireServer({selectedSkill1, selectedSkill2}) end})

local SkillsModule = require(ReplicatedStorage.ClientModules:WaitForChild("AbilityConfig"))
local guiStorage = lp:FindFirstChild("SkillScreenGui") or Instance.new("ScreenGui")
guiStorage.Name = "SkillScreenGui"
guiStorage.ResetOnSpawn = false
guiStorage.IgnoreGuiInset = true
guiStorage.Parent = lp:WaitForChild("PlayerGui")

local buttonConfigs = {}
local lastUsed = {}

local function makeDraggable(frame, skillName)
    local dragging, dragStart, startPos = false, Vector2.new(), frame.Position
    local function update(input)
        local delta = input.Position - dragStart
        frame.Position = UDim2.new(startPos.X.Scale, startPos.X.Offset+delta.X, startPos.Y.Scale, startPos.Y.Offset+delta.Y)
    end
    local function onInputBegan(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
            dragging = true
            dragStart = input.Position
            startPos = frame.Position
            input.Changed:Connect(function()
                if input.UserInputState == Enum.UserInputState.End then
                    dragging = false
                    buttonConfigs[skillName].pos = {frame.Position.X.Offset, frame.Position.Y.Offset}
                end
            end)
        end
    end
    local function onInputChanged(input)
        if dragging and (input.UserInputType==Enum.UserInputType.MouseMovement or input.UserInputType==Enum.UserInputType.Touch) then
            update(input)
        end
    end
    frame.InputBegan:Connect(onInputBegan)
    frame.InputChanged:Connect(onInputChanged)
    for _, child in ipairs(frame:GetDescendants()) do
        if child:IsA("GuiObject") then
            child.InputBegan:Connect(onInputBegan)
            child.InputChanged:Connect(onInputChanged)
        end
    end
end

local function createSkillButton(skillName)
    local skillData = SkillsModule[skillName]
    if not skillData then return end
    local cfg = buttonConfigs[skillName] or {size=46,pos={100,100}}
    buttonConfigs[skillName] = cfg
    local old = guiStorage:FindFirstChild(skillName.."_Btn")
    if old then old:Destroy() end
    local btnFrame = Instance.new("Frame")
    btnFrame.Name = skillName.."_Btn"
    btnFrame.Size = UDim2.new(0,cfg.size,0,cfg.size)
    btnFrame.Position = UDim2.new(0,cfg.pos[1],0,cfg.pos[2])
    btnFrame.BackgroundTransparency = 1
    btnFrame.Parent = guiStorage
    local border = Instance.new("UIStroke")
    border.Thickness = 2
    border.Color = Color3.fromRGB(197,197,197)
    border.Parent = btnFrame
    local innerFrame = Instance.new("Frame")
    innerFrame.Size = UDim2.new(1,0,1,0)
    innerFrame.BackgroundColor3 = Color3.fromRGB(0,0,0)
    innerFrame.BackgroundTransparency = 0.5
    innerFrame.BorderSizePixel = 0
    innerFrame.Parent = btnFrame
    local icon = Instance.new("ImageLabel")
    icon.Size = UDim2.new(0.9,0,0.9,0)
    icon.Position = UDim2.new(0.5,0,0.5,0)
    icon.AnchorPoint = Vector2.new(0.5,0.5)
    icon.BackgroundTransparency = 1
    icon.Image = skillData.Icon or ""
    icon.ScaleType = Enum.ScaleType.Fit
    icon.Parent = innerFrame
    local cooldownOverlay = Instance.new("Frame")
    cooldownOverlay.Size = UDim2.new(1,0,1,0)
    cooldownOverlay.BackgroundColor3 = Color3.fromRGB(0,0,0)
    cooldownOverlay.BackgroundTransparency = 0.6
    cooldownOverlay.BorderSizePixel = 0
    cooldownOverlay.Visible = false
    cooldownOverlay.Parent = innerFrame
    local cdLabel = Instance.new("TextLabel")
    cdLabel.Size = UDim2.new(1,0,1,0)
    cdLabel.BackgroundTransparency = 1
    cdLabel.TextColor3 = Color3.fromRGB(255,255,255)
    cdLabel.TextScaled = true
    cdLabel.Font = Enum.Font.GothamBold
    cdLabel.Visible = false
    cdLabel.Parent = cooldownOverlay
    local button = Instance.new("TextButton")
    button.Size = UDim2.new(1,0,1,0)
    button.BackgroundTransparency = 1
    button.Text = ""
    button.Parent = innerFrame
    button.MouseButton1Click:Connect(function()
        local cooldown = tonumber(skillData.Cooldown) or 1
        local now = os.clock()
        if not lastUsed[skillName] or now - lastUsed[skillName] >= cooldown then
            lastUsed[skillName] = now
            local remoteFunc = ReplicatedStorage:WaitForChild("Events"):WaitForChild("RemoteFunctions"):WaitForChild("UseAbility")
            pcall(function() remoteFunc:InvokeServer(skillName) end)
            cooldownOverlay.Visible = true
            cdLabel.Visible = true
            task.spawn(function()
                local t = cooldown
                while t > 0 do
                    cdLabel.Text = tostring(math.ceil(t))
                    task.wait(1)
                    t -= 1
                end
                cooldownOverlay.Visible = false
                cdLabel.Visible = false
            end)
        end
    end)
    makeDraggable(btnFrame, skillName)
end

local function removeSkillButton(skillName)
    local old = guiStorage:FindFirstChild(skillName.."_Btn")
    if old then old:Destroy() end
end

for _, skillName in ipairs(skillList) do
    local enabled = false
    tabSkills:CreateToggle({
        Name = "Enable "..skillName,
        CurrentValue = false,
        Callback = function(v)
            enabled = v
            if v then createSkillButton(skillName) else removeSkillButton(skillName) end
        end
    })
    tabSkills:CreateSlider({
        Name = skillName.." Size",
        Range = {40,120},
        Increment = 1,
        CurrentValue = 46,
        Callback = function(val)
            if not buttonConfigs[skillName] then
                buttonConfigs[skillName] = {size=val,pos={100,100}}
            else
                buttonConfigs[skillName].size = val
            end
            if enabled then createSkillButton(skillName) end
        end
    })
end

-- ========== GAMEPLAY SETTINGS ==========
local tabGameplay = Window:CreateTab("Gameplay Settings", 4483362458)

local lockWSM = true
tabGameplay:CreateToggle({Name="Lock WalkSpeedModifier", CurrentValue=lockWSM, Callback=function(v) lockWSM=v end})

local keepStaminaEnabled = true
local customStamina = 100
local defaultStamina = ((lp.Character or lp.CharacterAdded:Wait()):GetAttribute("MaxStamina")) or 100

tabGameplay:CreateToggle({
    Name="Enable Custom MaxStamina",
    CurrentValue=keepStaminaEnabled,
    Callback=function(v)
        keepStaminaEnabled=v
        if lp.Character then
            lp.Character:SetAttribute("MaxStamina", v and customStamina or defaultStamina)
        end
    end
})

tabGameplay:CreateInput({
    Name="Custom MaxStamina (0-999999)",
    PlaceholderText="Enter number...",
    RemoveTextAfterFocusLost=true,
    Callback=function(text)
        local num = tonumber(text)
        if num and num>=0 and num<=999999 then
            customStamina=num
            if keepStaminaEnabled and lp.Character then
                lp.Character:SetAttribute("MaxStamina",customStamina)
            end
        end
    end
})

mainConns.staminaHB = RunService.Heartbeat:Connect(function()
    if unloaded then return end
    local char = lp.Character
    local hum = char and char:FindFirstChildOfClass("Humanoid")
    if not hum then return end
    if lockWSM then
        for _, obj in pairs({hum,char,lp}) do
            if obj and obj.GetAttributes then
                local attrs = obj:GetAttributes()
                if attrs then
                    for name,val in pairs(attrs) do
                        if typeof(name)=="string" and name:lower():find("walkspeedmodifier") then
                            if val<=0 then obj:SetAttribute(name,0) end
                        end
                    end
                end
            end
        end
    end
    if keepStaminaEnabled and char then
        if char:GetAttribute("MaxStamina")~=customStamina then
            char:SetAttribute("MaxStamina",customStamina)
        end
    elseif char then
        if char:GetAttribute("MaxStamina")~=defaultStamina then
            char:SetAttribute("MaxStamina",defaultStamina)
        end
    end
end)

mainConns.charAdded_gameplay = lp.CharacterAdded:Connect(function(char)
    local hum = char:WaitForChild("Humanoid", 10)
    if not hum then return end
    if keepStaminaEnabled then char:SetAttribute("MaxStamina",customStamina)
    else char:SetAttribute("MaxStamina",defaultStamina) end
    if lockWSM then
        for _, obj in pairs({hum,char,lp}) do
            if obj and obj.GetAttributes then
                local attrs = obj:GetAttributes()
                if attrs then
                    for name,val in pairs(attrs) do
                        if typeof(name)=="string" and name:lower():find("walkspeedmodifier") then
                            if val<=0 then obj:SetAttribute(name,0) end
                        end
                    end
                end
            end
        end
    end
end)

local AntiWalls = false
tabGameplay:CreateToggle({Name="Anti-Artful Walls", CurrentValue=AntiWalls, Callback=function(v) AntiWalls=v end})

local function HandleWallPart(part)
    if part and part:IsA("BasePart") and part.Name=="HumanoidRootPart" and part.Anchored==true then
        pcall(function()
            part.CanCollide=false
            part.CanTouch=false
            part.Transparency=0.5
        end)
    end
end

task.spawn(function()
    while not unloaded do
        task.wait(0.5)
        if AntiWalls then
            pcall(function()
                local ga = Workspace:FindFirstChild("GameAssets")
                if not ga then return end
                local teams = ga:FindFirstChild("Teams")
                if not teams then return end
                local other = teams:FindFirstChild("Other")
                if not other then return end
                for _, desc in pairs(other:GetDescendants()) do
                    if desc:IsA("BasePart") then
                        HandleWallPart(desc)
                    end
                end
            end)
        end
    end
end)

local otherTeamFolder = Workspace:WaitForChild("GameAssets"):WaitForChild("Teams"):WaitForChild("Other")
otherTeamFolder.DescendantAdded:Connect(function(desc)
    if AntiWalls then HandleWallPart(desc) end
end)

getgenv().ImplementEnabled=false
local canTrigger=true

local function getKillerFolder()
    local ga = Workspace:FindFirstChild("GameAssets")
    if not ga then return nil end
    local teams = ga:FindFirstChild("Teams")
    if not teams then return nil end
    return teams:FindFirstChild("Killer")
end

local function HoldImpl_isKiller()
    local kf = getKillerFolder()
    if not kf then return false end
    return kf:FindFirstChild(lp.Name)~=nil
end

local function HoldImpl_holdInAir(duration,offsetY)
    local char = lp.Character
    local hrp = char and char:FindFirstChild("HumanoidRootPart")
    if not hrp or not hrp.Parent then return end
    local bp = Instance.new("BodyPosition")
    bp.Position = hrp.Position + Vector3.new(0,offsetY,0)
    bp.MaxForce = Vector3.new(math.huge,math.huge,math.huge)
    bp.P = 100000
    bp.D = 1000
    bp.Parent = hrp
    task.spawn(function()
        task.wait(duration)
        if bp and bp.Parent then bp:Destroy() end
    end)
end

local function HoldImpl_CheckAttributes()
    if not getgenv().ImplementEnabled then return end
    local char = lp.Character
    local hrp = char and char:FindFirstChild("HumanoidRootPart")
    if not char or not hrp then return end
    if not HoldImpl_isKiller() then return end
    local killerName = char:GetAttribute("KillerName")
    local implementCooldown = char:GetAttribute("ImplementCooldown")
    if killerName=="Artful" and canTrigger and (implementCooldown==true or (type(implementCooldown)=="number" and implementCooldown>0)) then
        HoldImpl_holdInAir(2,2.5)
        canTrigger=false
    end
    if implementCooldown==false or implementCooldown==0 then canTrigger=true end
end

task.spawn(function()
    while task.wait(1) do
        HoldImpl_CheckAttributes()
        if unloaded then break end
    end
end)
lp.CharacterAdded:Connect(function() canTrigger=true end)

tabGameplay:CreateToggle({Name="Implement Fast Artful", CurrentValue=getgenv().ImplementEnabled, Callback=function(v) getgenv().ImplementEnabled=v if v then HoldImpl_CheckAttributes() end end})

local noM1Enabled = false
local CHECK_INTERVAL = 0.5
local hideState = false
local blockerList = {}

tabGameplay:CreateToggle({Name = "No M1 when Blocking (You Killer)", CurrentValue = noM1Enabled, Callback = function(v) noM1Enabled = v end})

local survivorFolder = Workspace:WaitForChild("GameAssets"):WaitForChild("Teams"):WaitForChild("Survivor")
local killerFolderM1 = Workspace:WaitForChild("GameAssets"):WaitForChild("Teams"):WaitForChild("Killer")
local PlayerGui = lp:WaitForChild("PlayerGui")
local ABILITY_FOLDER = PlayerGui.MainGui.Abilities:WaitForChild("Folder")
local TARGET_NAMES = { Swing = true, Cleave = true, Eject = true }

local function hideButtons()
    if hideState then return end
    hideState = true
    for _, child in ipairs(ABILITY_FOLDER:GetChildren()) do
        if TARGET_NAMES[child.Name] and child:IsA("GuiObject") then
            child.Visible = false
            child.Active = false
            if child:IsA("ImageButton") or child:IsA("TextButton") then
                child.AutoButtonColor = false
            end
        end
    end
end

local function showButtons()
    if not hideState then return end
    hideState = false
    for _, child in ipairs(ABILITY_FOLDER:GetChildren()) do
        if TARGET_NAMES[child.Name] and child:IsA("GuiObject") then
            child.Visible = true
            child.Active = true
            if child:IsA("ImageButton") or child:IsA("TextButton") then
                child.AutoButtonColor = true
            end
        end
    end
end

local function isInRange(target)
    local char = lp.Character
    if not (char and char:FindFirstChild("HumanoidRootPart")) then return false end
    local root = char.HumanoidRootPart
    local targetRoot = target:FindFirstChild("HumanoidRootPart")
    if not targetRoot then return false end
    return (root.Position - targetRoot.Position).Magnitude <= DETECTION_RANGE
end

local function watchPlayer(playerModel)
    if not playerModel:IsDescendantOf(survivorFolder) then return end
    local name = playerModel.Name
    local function updateBlockState()
        local state = playerModel:GetAttribute("Blocking")
        if state then
            blockerList[name] = playerModel
        else
            blockerList[name] = nil
        end
    end
    if playerModel:GetAttribute("Blocking") then
        blockerList[name] = playerModel
    end
    playerModel.AttributeChanged:Connect(function(attr)
        if attr == "Blocking" then
            updateBlockState()
        end
    end)
end

for _, survivor in ipairs(survivorFolder:GetChildren()) do
    if survivor:IsA("Model") then
        pcall(function() watchPlayer(survivor) end)
    end
end

survivorFolder.ChildAdded:Connect(function(plr)
    task.wait(0.1)
    if plr:IsA("Model") then
        pcall(function() watchPlayer(plr) end)
    end
end)

task.spawn(function()
    while task.wait(CHECK_INTERVAL) do
        if not noM1Enabled then
            showButtons()
            continue
        end
        local isKiller = killerFolderM1:FindFirstChild(lp.Name)
        if not isKiller then
            showButtons()
            continue
        end
        local shouldHide = false
        for _, model in pairs(blockerList) do
            if model and model:IsDescendantOf(survivorFolder) and isInRange(model) then
                shouldHide = true
                break
            end
        end
        if shouldHide then hideButtons() else showButtons() end
    end
end)

-- ========== SETTINGS TAB ==========
local tabSettings = Window:CreateTab("Settings",4483362458)
local instantPPEnabled = true
local proximityPrompts = {}

local function updateProximityPrompts()
    for prompt, _ in pairs(proximityPrompts) do
        if prompt and prompt:IsA("ProximityPrompt") then
            if instantPPEnabled then
                prompt.HoldDuration = 0
            else
                prompt.HoldDuration = prompt:GetAttribute("OriginalHoldDuration") or 1
            end
        end
    end
end

local function handleProximityPrompt(prompt)
    if prompt:IsA("ProximityPrompt") then
        if prompt:GetAttribute("OriginalHoldDuration") == nil then
            prompt:SetAttribute("OriginalHoldDuration", prompt.HoldDuration)
        end
        proximityPrompts[prompt] = true
        if instantPPEnabled then
            prompt.HoldDuration = 0
        end
        prompt.AncestryChanged:Connect(function()
            if not prompt:IsDescendantOf(Workspace) then
                proximityPrompts[prompt] = nil
            end
        end)
    end
end

local otherFolderPP = Workspace:WaitForChild("GameAssets", 5)
    and Workspace.GameAssets:WaitForChild("Teams", 5)
    and Workspace.GameAssets.Teams:WaitForChild("Other", 5)

if otherFolderPP then
    for _, obj in pairs(otherFolderPP:GetDescendants()) do
        handleProximityPrompt(obj)
    end
    mainConns.workspaceDescendant = otherFolderPP.DescendantAdded:Connect(handleProximityPrompt)
end

tabSettings:CreateToggle({Name = "Instant ProximityPrompt", CurrentValue = instantPPEnabled, Callback = function(v) instantPPEnabled = v updateProximityPrompts() end})

tabSettings:CreateButton({
    Name="Unload Script",
    Callback=function()
        if unloaded then return end
        unloaded=true
        if Storage and Storage:IsA("Instance") then
            pcall(function() Storage:ClearAllChildren() end)
        end
        for plr,conns in pairs(connections) do
            if conns then
                for _,conn in pairs(conns) do
                    if typeof(conn)=="RBXScriptConnection" then pcall(function() conn:Disconnect() end) end
                end
            end
            connections[plr]=nil
        end
        for k,conn in pairs(mainConns) do
            if conn and typeof(conn)=="RBXScriptConnection" then pcall(function() conn:Disconnect() end) end
            mainConns[k]=nil
        end
        local g = CoreGui:FindFirstChild("Rayfield")
        if g then pcall(function() g:Destroy() end) end
        local abGui = lp.PlayerGui:FindFirstChild("AutoBlockCooldown")
        if abGui then pcall(function() abGui:Destroy() end) end
        local skillGui = lp.PlayerGui:FindFirstChild("SkillScreenGui")
        if skillGui then pcall(function() skillGui:Destroy() end) end
        for killer, _ in pairs(facingVisuals) do
            removeFacingVisual(killer)
        end
        warn("[SCRIPT] Unloaded successfully.")
    end
})

-- ========== ANIMATION TAB ==========
local animationTab = Window:CreateTab("Animation", 4483362458)
local selectedAnimation = "Old"

local animationSets = {
    Old = {
        Adrenaline = "77399794134778",
        AdrenalineEnd = "92333601998082",
        Banana = "95775571866935",
        BlockLand = "94027412516651",
        BlockStart = "100651795910153",
        Caretaker = "136588017093606",
        CloakStart = "117841747115136",
        Dash = "82265255195607",
        DynamiteHold = "137091713941325",
        DynamiteThrow = "99551865645121",
        DynamiteWindup = "133960279206605",
        Hotdog = "93503428349113",
        PadBuild = "82160380573308",
        Punch = "135619604085485",
        Revolver = "73034688541555",
        RevolverReload = "74813841922695",
        Taunt = "113732291990231"
    },
    New = {
        Adrenaline = "77399794134778",
        AdrenalineEnd = "92333601998082",
        Banana = "95775571866935",
        BlockLand = "94027412516651",
        BlockStart = "134233326423882",
        Caretaker = "128767098320893",
        CloakEnd = "120142279051418",
        CloakStart = "133960698072483",
        Dash = "78278813483757",
        DynamiteHold = "137091713941325",
        DynamiteThrow = "99551865645121",
        DynamiteWindup = "133960279206605",
        Hotdog = "78595119178919",
        PadBuild = "79104831518074",
        Punch = "124781750889573",
        Revolver = "74108653904830",
        RevolverReload = "79026181033717",
        Taunt = "113732291990231"
    }
}

local function getAbilitiesFolder()
    local playerName = lp.Name
    local abilitiesFolder
    local survivorPath = workspace:FindFirstChild("GameAssets")
        and workspace.GameAssets:FindFirstChild("Teams")
        and workspace.GameAssets.Teams:FindFirstChild("Survivor")
        and workspace.GameAssets.Teams.Survivor:FindFirstChild(playerName)
    if survivorPath and survivorPath:FindFirstChild("Animations") and survivorPath.Animations:FindFirstChild("Abilities") then
        abilitiesFolder = survivorPath.Animations.Abilities
    end
    if not abilitiesFolder then
        local localModel = workspace:FindFirstChild(playerName)
        if localModel and localModel:GetChildren()[13] and localModel:GetChildren()[13]:FindFirstChild("Abilities") then
            abilitiesFolder = localModel:GetChildren()[13].Abilities
        end
    end
    return abilitiesFolder
end

local function replaceAnimations(animationSet)
    if not animationSet or type(animationSet) ~= "table" then
        warn("[Animation] Invalid animation set!")
        return
    end
    local abilitiesFolder = getAbilitiesFolder()
    if not abilitiesFolder then
        warn("[Animation] Cannot find Abilities folder!")
        return
    end
    for name, id in pairs(animationSet) do
        if id == "0" or id == "" then
           continue
        end
        local anim = abilitiesFolder:FindFirstChild(name)
        if anim and anim:IsA("Animation") then
            local success, err = pcall(function()
                anim.AnimationId = "rbxassetid://" .. id
            end)
            if not success then
                warn("[Animation] Failed to set "..name..": "..tostring(err))
            end
        end
        task.wait(0.05)
    end
end

animationTab:CreateButton({Name = "Anim Skill Old", Callback = function() selectedAnimation = "Old" replaceAnimations(animationSets.Old) end})
animationTab:CreateButton({Name = "Anim Skill New", Callback = function() selectedAnimation = "New" replaceAnimations(animationSets.New) end})

lp.CharacterAdded:Connect(function(char)
    task.wait(1)
    if animationSets[selectedAnimation] then
        replaceAnimations(animationSets[selectedAnimation])
    end
end)

-- ========== OTHER TAB ==========
local tabOther = Window:CreateTab("Other", 115233777642994)

tabOther:CreateButton({
    Name = "Change Animation V2",
    Callback = function()
        local success, err = pcall(function()
            loadstring(game:HttpGet("https://gist.githubusercontent.com/tranvanxanh0502-afk/be6bf6dc9e3f5c2beb438418277af445/raw/d66fc9b710a26454b5eb1787f1b79bc00024ecb0/I%2520am%2520not%2520the%2520owner,%2520just%2520an%2520update", true))()
        end)
        if not success then
            warn("[Other Tab] Failed to load script: "..tostring(err))
        end
    end
})

tabOther:CreateButton({
    Name = "Flip Script",
    Callback = function()
        local success, err = pcall(function()
            loadstring(game:HttpGet("https://raw.githubusercontent.com/SHRTRYScriptMANhere/stolenahhfrotflip/refs/heads/main/Flip", true))()
        end)
        if not success then
            warn("[Other Tab] Failed to load Flip script: "..tostring(err))
        end
    end
})

print("[SCRIPT] Loaded successfully!")
print("[INFO] Features: ESP, Speed, AutoBlock ULTRA (0ms/15 studs, optional facing check), Skills, Gameplay Settings, Animations")
print("[AutoBlock ULTRA v3.0] INSTANT 0")
